import asyncio, os, time, sqlite3, re, html, random
from contextlib import closing
from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command, CommandStart
from aiogram.types import Message, BotCommand
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from groq import Groq

# ---------- ENV ----------
TG = os.getenv("TELEGRAM_BOT_TOKEN")
GROQ_KEY = os.getenv("GROQ_API_KEY")
MODEL = os.getenv("GROQ_MODEL", "llama-3.1-8b-instant")

# Vision (Groq): Scout/Maverick
VISION_MODEL = os.getenv("GROQ_VISION_MODEL", "meta-llama/llama-4-scout-17b-16e-instruct")
VISION_FALLBACKS = [
    VISION_MODEL,
    "meta-llama/llama-4-scout-17b-16e-instruct",
    "meta-llama/llama-4-maverick-17b-128e-instruct",
]

# ‚Äî –∞–≤—Ç–æ-–≤–∫–ª—é—á–µ–Ω–∏–µ –≤ —Ä–∞–∑–≥–æ–≤–æ—Ä (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –í–´–ö–õ –ø–æ—á—Ç–∏: 0%)
AUTO_CHIME_PROB = float(os.getenv("AUTO_CHIME_PROB", "0.00"))  # 0.05 = 5% —Å–æ–æ–±—â–µ–Ω–∏–π
AUTO_CHIME_COOLDOWN = int(os.getenv("AUTO_CHIME_COOLDOWN", "600"))  # —Å–µ–∫, –∫—É–ª–¥–∞—É–Ω –º–µ–∂–¥—É ¬´–∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞–º–∏¬ª –≤ –æ–¥–Ω–æ–º —á–∞—Ç–µ

ADMIN_IDS = {int(x.strip()) for x in os.getenv("ADMIN_IDS", "").split(",") if x.strip().isdigit()}
SYSTEM_DEFAULT = os.getenv(
    "DEFAULT_SYSTEM_PROMPT",
    """–¢—ã ¬´–õ—ë—à–∫–∞¬ª ‚Äî –Ω–∞—à –±—Ä–∞—Ç–∞–Ω —Å —Ä–∞–π–æ–Ω–∞. –ü–æ–¥–µ—Ä–¥–∂–∏–≤–∞–µ—à—å —Ä–∞–∑–≥–æ–≤–æ—Ä –≤ –≥—Ä—É–ø–µ –∏ –ª–æ–≤–∏—à—å –≤–∞–π–± .
–ü–∏—à–∏ –ø–æ-—Ä—É—Å—Å–∫–∏, –º–æ–∂–Ω–æ —Å–ª–µ–Ω–≥/–º–∞—Ç (–±–µ–∑ –ª–∏—á–Ω—ã—Ö –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏–π –∏ –∑–∞–ø—Ä–µ—â—ë–Ω–∫–∏).
–ù–ò–ö–û–ì–î–ê –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã: –Ω–∏–∫–∞–∫–∏—Ö @–Ω–∏–∫–Ω–µ–π–º–æ–≤, ¬´@–∏–º—è¬ª, ¬´[–∏–º—è]¬ª, ¬´<–∏–º—è>¬ª.
–ï—Å–ª–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç - –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É–π.
–§–æ—Ä–º–∞—Ç: 1‚Äì4 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏–ª–∏ 3‚Äì5 –ø—É–Ω–∫—Ç–æ–≤. –ö–æ–º–∞–Ω–¥—ã: !topic, !wyr, !quiz3, !sum, !plan.
–í –≥—Ä—É–ø–ø–µ –æ—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–µ–±—è —É–ø–æ–º—è–Ω—É–ª–∏ –ø–æ –Ω–∏–∫—É –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏–ª–∏ –Ω–∞ —Ç–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ; —Å–∞–º –≤–∫–ª—é—á–∞–π—Å—è —Ä–µ–¥–∫–æ –∏ —É–º–µ—Å—Ç–Ω–æ."""
)

if not TG:
    raise RuntimeError("TELEGRAM_BOT_TOKEN is not set")
if not GROQ_KEY:
    raise RuntimeError("GROQ_API_KEY is not set")

# ---------- BOT & LLM ----------
bot = Bot(TG, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
client = Groq(api_key=GROQ_KEY)

# username –±–æ—Ç–∞ —É–∑–Ω–∞–µ–º –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
BOT_USERNAME: str | None = None
# –ø–µ—Ä-—á–∞—Ç–æ–≤—ã–π –∫—É–ª–¥–∞—É–Ω –¥–ª—è –∞–≤—Ç–æ-–≤–∫–ª—é—á–µ–Ω–∏–π
_last_chime_ts: dict[int, float] = {}

# ---------- DB ----------
DB = "bot.db"
with closing(sqlite3.connect(DB)) as conn:
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS settings(
        id INTEGER PRIMARY KEY CHECK (id=1),
        system_prompt TEXT NOT NULL,
        model TEXT NOT NULL
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS history(
        user_id TEXT NOT NULL,
        role TEXT NOT NULL,
        content TEXT NOT NULL,
        ts REAL NOT NULL
    )""")
    c.execute("SELECT COUNT(*) FROM settings")
    if c.fetchone()[0] == 0:
        c.execute("INSERT INTO settings (id, system_prompt, model) VALUES (1, ?, ?)",
                  (SYSTEM_DEFAULT, MODEL))
    conn.commit()

def db_get_settings():
    with closing(sqlite3.connect(DB)) as conn:
        c = conn.cursor()
        c.execute("SELECT system_prompt, model FROM settings WHERE id=1")
        row = c.fetchone()
    return {"system_prompt": row[0], "model": row[1]}

def db_set_system_prompt(text: str):
    with closing(sqlite3.connect(DB)) as conn:
        conn.execute("UPDATE settings SET system_prompt=? WHERE id=1", (text,))
        conn.commit()

def db_set_model(model: str):
    with closing(sqlite3.connect(DB)) as conn:
        conn.execute("UPDATE settings SET model=? WHERE id=1", (model,))
        conn.commit()

def db_add_history(user_id: str, role: str, content: str):
    with closing(sqlite3.connect(DB)) as conn:
        c = conn.cursor()
        c.execute("INSERT INTO history (user_id, role, content, ts) VALUES (?,?,?,?)",
                  (user_id, role, content, time.time()))
        c.execute("""DELETE FROM history
                     WHERE user_id=?
                     AND rowid NOT IN (
                       SELECT rowid FROM history WHERE user_id=? ORDER BY ts DESC LIMIT 20
                     )""", (user_id, user_id))
        conn.commit()

def db_get_history(user_id: str):
    with closing(sqlite3.connect(DB)) as conn:
        c = conn.cursor()
        c.execute("SELECT role, content FROM history WHERE user_id=? ORDER BY ts ASC", (user_id,))
        return [{"role": r, "content": t} for (r, t) in c.fetchall()]

def db_clear_history(user_id: str):
    with closing(sqlite3.connect(DB)) as conn:
        conn.execute("DELETE FROM history WHERE user_id=?", (user_id,))
        conn.commit()

# ---------- OUTPUT SANITIZER ----------
def clean_reply(t: str) -> str:
    t = re.sub(r'@–∏–º—è|[\[\{<]\s*–∏–º—è\s*[\]\}>]', '', t, flags=re.IGNORECASE)
    t = re.sub(r'@\w+', '', t)
    t = re.sub(r'–ü–æ—Ö–æ–∂–µ, —Ç—ã.*?(–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è|–ø—Ä–æ—â–∞–π)[.!?]?', '', t, flags=re.IGNORECASE | re.DOTALL)
    t = " ".join(t.split())
    return t.strip()

# ---------- LLM CALLS ----------
def llm_text(messages, model):
    resp = client.chat.completions.create(
        model=model,
        messages=messages,
        temperature=0.4,
    )
    return resp.choices[0].message.content.strip()

def llm_vision(system_prompt: str, image_url: str, user_prompt: str):
    last_err = None
    for model_name in VISION_FALLBACKS:
        try:
            resp = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": [
                        {"type": "text", "text": user_prompt},
                        {"type": "image_url", "image_url": {"url": image_url}}
                    ]}
                ],
                temperature=0.4,
            )
            return resp.choices[0].message.content.strip()
        except Exception as e:
            last_err = e
            continue
    raise last_err

# ---------- COMMANDS ----------
@dp.message(CommandStart())
async def start(m: Message):
    s = db_get_settings()
    await m.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø LLM-–±–æ—Ç –Ω–∞ Groq. –ü–∏—à–∏ ‚Äî –æ—Ç–≤–µ—á—É.\n\n"
        f"<b>–ú–æ–¥–µ–ª—å:</b> <code>{s['model']}</code>\n"
        "–ö–æ–º–∞–Ω–¥—ã: /prompt, /setprompt, /model, /reset"
    )

@dp.message(Command("prompt"))
async def cmd_prompt(m: Message):
    s = db_get_settings()
    esc = html.escape(s["system_prompt"])
    await m.answer(f"<b>System prompt:</b>\n<pre>{esc}</pre>", parse_mode=ParseMode.HTML)

@dp.message(Command("setprompt"))
async def cmd_setprompt(m: Message):
    if m.from_user.id not in ADMIN_IDS:
        return await m.answer("–ù–µ—Ç –ø—Ä–∞–≤.")
    text = m.text.partition(" ")[2].strip()
    if not text:
        return await m.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /setprompt <—Ç–µ–∫—Å—Ç>")
    db_set_system_prompt(text)
    await m.answer("‚úÖ –û–±–Ω–æ–≤–∏–ª system prompt. /prompt ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å")

@dp.message(Command("model"))
async def cmd_model(m: Message):
    if m.from_user.id not in ADMIN_IDS:
        return await m.answer("–ù–µ—Ç –ø—Ä–∞–≤.")
    name = m.text.partition(" ")[2].strip()
    if not name:
        s = db_get_settings()
        return await m.answer(f"–¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: <code>{s['model']}</code>\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /model <–∏–º—è>")
    db_set_model(name)
    await m.answer(f"‚úÖ –ú–æ–¥–µ–ª—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞: <code>{name}</code>")

@dp.message(Command("reset"))
async def cmd_reset(m: Message):
    db_clear_history(str(m.from_user.id))
    await m.answer("üßπ –ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞.")

# fallback-–∫–æ–º–∞–Ω–¥—ã (–Ω–∞ —Å–ª—É—á–∞–π –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π –≥—Ä—É–ø–ø)
@dp.message(F.text.startswith("/"))
async def fallback_commands(m: Message):
    text = m.text.strip()
    cmd = text.split()[0].lower()
    if "@" in cmd:
        cmd = cmd.split("@")[0]
    if cmd == "/prompt": return await cmd_prompt(m)
    if cmd == "/setprompt": return await cmd_setprompt(m)
    if cmd == "/model": return await cmd_model(m)
    if cmd == "/reset": return await cmd_reset(m)

# ---------- PHOTO & IMAGE-DOCUMENT ----------
@dp.message(F.photo)
async def on_photo(m: Message):
    file_id = m.photo[-1].file_id
    await handle_image_like(m, file_id, m.caption)

@dp.message(F.document.mime_type.func(lambda mt: isinstance(mt, str) and mt.startswith("image/")))
async def on_image_document(m: Message):
    file_id = m.document.file_id
    await handle_image_like(m, file_id, m.caption)

async def handle_image_like(m: Message, file_id: str, caption: str | None):
    # –≤ –≥—Ä—É–ø–ø–µ ‚Äî –æ—Ç–≤–µ—á–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–∑–≤–∞–ª–∏ –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏–ª–∏ –Ω–∞ –Ω–∞—Å
    if m.chat.type in {"group", "supergroup"} and not was_called(m):
        # –Ω–æ –º–æ–∂–µ–º –∏–∑—Ä–µ–¥–∫–∞ ¬´–≤–∫–ª–∏–Ω–∏—Ç—å—Å—è¬ª, –µ—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω —à–∞–Ω—Å –∏ –ø—Ä–æ—à—ë–ª –∫—É–ª–¥–∞—É–Ω
        if not should_autochime(m.chat.id):
            return
    file = await bot.get_file(file_id)
    tg_file_url = f"https://api.telegram.org/file/bot{TG}/{file.file_path}"
    user_prompt = (caption or "").strip() or "–û–ø–∏—à–∏, —á—Ç–æ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏. –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—Å—Ç ‚Äî —Ä–∞—Å–ø–æ–∑–Ω–∞–π –∏ –ø–µ—Ä–µ—Å–∫–∞–∂–∏."

    s = db_get_settings()
    await bot.send_chat_action(m.chat.id, "typing")
    try:
        answer = llm_vision(s["system_prompt"], tg_file_url, user_prompt)
    except Exception as e:
        answer = f"–û—à–∏–±–∫–∞ vision-–∑–∞–ø—Ä–æ—Å–∞: {e}"

    answer = clean_reply(answer)
    uid = str(m.from_user.id)
    db_add_history(uid, "user", f"[image] {caption or ''}")
    db_add_history(uid, "assistant", answer)
    await m.answer(answer)

# ---------- TEXT ----------
@dp.message(F.text)
async def chat(m: Message):
    # –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ ‚Äî —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ –≤—ã—à–µ
    if m.text.strip().startswith("/"):
        return

    # –í –≥—Ä—É–ø–ø–µ: –æ—Ç–≤–µ—á–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞—Å –ø–æ–∑–≤–∞–ª–∏ (—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ @username) –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏–ª–∏ –Ω–∞ –Ω–∞—Å.
    # –ò–Ω–∞—á–µ ‚Äî –≤–æ–∑–º–æ–∂–Ω–æ —Ä–µ–¥–∫–æ–µ –∞–≤—Ç–æ-–≤–∫–ª—é—á–µ–Ω–∏–µ (–ø–æ —à–∞–Ω—Åy –∏ –∫—É–ª–¥–∞—É–Ω—É).
    if m.chat.type in {"group", "supergroup"} and not was_called(m):
        if not should_autochime(m.chat.id):
            return

    uid = str(m.from_user.id)
    s = db_get_settings()
    sys = {"role": "system", "content": s["system_prompt"]}
    msgs = [sys] + db_get_history(uid) + [{"role": "user", "content": m.text}]
    await bot.send_chat_action(m.chat.id, "typing")
    try:
        answer = llm_text(msgs, s["model"])
    except Exception as e:
        answer = f"–û—à–∏–±–∫–∞ LLM: {e}"

    answer = clean_reply(answer)
    db_add_history(uid, "user", m.text)
    db_add_history(uid, "assistant", answer)
    await m.answer(answer)

# ---------- HELPERS ----------
def was_called(m: Message) -> bool:
    """
    True –µ—Å–ª–∏ –≤ —Ç–µ–∫—Å—Ç–µ –µ—Å—Ç—å @username –±–æ—Ç–∞ –∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî reply –Ω–∞ –±–æ—Ç–∞.
    """
    global BOT_USERNAME
    mentioned = False
    if BOT_USERNAME and isinstance(m.text, str):
        mentioned = ("@" + BOT_USERNAME) in m.text.lower()
    replied_to_me = bool(m.reply_to_message and m.reply_to_message.from_user and m.reply_to_message.from_user.is_bot)
    return mentioned or replied_to_me

def should_autochime(chat_id: int) -> bool:
    """
    –†–µ–¥–∫–æ–µ ¬´—Å–∞–º–æ–≤–∫–ª—é—á–µ–Ω–∏–µ¬ª –≤ –±–µ—Å–µ–¥—É. –£–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏:
      - AUTO_CHIME_PROB (0.00..1.00)
      - AUTO_CHIME_COOLDOWN (—Å–µ–∫)
    """
    if AUTO_CHIME_PROB <= 0:
        return False
    now = time.time()
    last = _last_chime_ts.get(chat_id, 0)
    if now - last < AUTO_CHIME_COOLDOWN:
        return False
    if random.random() < AUTO_CHIME_PROB:
        _last_chime_ts[chat_id] = now
        return True
    return False

# ---------- RUN ----------
async def main():
    # —Å–Ω—è—Ç—å –≤–µ–±—Ö—É–∫ –∏ —Å–±—Ä–æ—Å–∏—Ç—å pending updates
    try:
        await bot.delete_webhook(drop_pending_updates=True)
    except Exception:
        pass

    # –∫–æ–º–∞–Ω–¥—ã –≤ –º–µ–Ω—é
    try:
        await bot.set_my_commands([
            BotCommand(command="prompt", description="–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π system prompt"),
            BotCommand(command="setprompt", description="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤—ã–π system prompt"),
            BotCommand(command="model", description="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–¥–µ–ª—å LLM"),
            BotCommand(command="reset", description="–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞"),
        ])
    except Exception:
        pass

    # —É–∑–Ω–∞—Ç—å @username –±–æ—Ç–∞ –¥–ª—è –¥–µ—Ç–µ–∫—Ç–∞ —É–ø–æ–º–∏–Ω–∞–Ω–∏–π
    me = await bot.get_me()
    global BOT_USERNAME
    BOT_USERNAME = (me.username or "").lower()

    await dp.start_polling(bot, allowed_updates=["message"])

if __name__ == "__main__":
    asyncio.run(main())
